
// ================================================================================================
// -*- C++ -*-
// File: neo_tweak_bar.cpp
// Author: Guilherme R. Lampert
// Created on: 07/01/16
// Brief: Neo Tweak Bar - a lightweight and intuitive C++ GUI library for graphics applications.
// ================================================================================================

#include "neo_tweak_bar.hpp"

//
//FIXME note:
// When using the StackAllocator, we shouldn't waste time
// calling list.unlinkAndDelete() / list.unlinkAndDeleteAll() !!!
//

namespace ntb
{

//FIXME temp stuff just for testing/development!
static int pan_xof = 0;
static int pan_yof = 0;

static const float g_uiScale = 1.3f;
#define NTB_SCALED_BY(val, scale) static_cast<int>(static_cast<float>(val) * (scale))
#define NTB_SCALED(val) NTB_SCALED_BY(val, g_uiScale)

// ========================================================
// Local library-shared data:
// ========================================================

static RenderInterface  * g_renderInterface = NTB_NULL;
static ShellInterface   * g_shellInterface  = NTB_NULL;
static StackAllocator   * g_stackAllocator  = NTB_NULL;
static bool               g_libraryIsInit   = false;

IntrusiveList & getGUIList()
{
    static IntrusiveList theGUIList;
    return theGUIList;
}

RenderInterface * getRenderInterface() { return g_renderInterface; }
ShellInterface  * getShellInterface()  { return g_shellInterface;  }
StackAllocator  * getStackAllocator()  { return g_stackAllocator;  }

// ========================================================
// Library initialization/shutdown and GUI allocation:
// ========================================================

bool initialize(RenderInterface * renderer, ShellInterface * shell, StackAllocator * stackAlloc)
{
    // These are required.
    if (renderer == NTB_NULL || shell == NTB_NULL)
    {
        return false;
    }

    g_renderInterface = renderer;
    g_shellInterface  = shell;
    g_stackAllocator  = stackAlloc;
    g_libraryIsInit   = true;
    return true;
}

void shutdown()
{
    //TODO temp
    getGUIList().unlinkAndDeleteAll();
    g_renderInterface = NTB_NULL;
    g_shellInterface  = NTB_NULL;
    g_stackAllocator  = NTB_NULL;
    g_libraryIsInit   = false;
}

GUI * createGUI(const char * guiName)
{
    if (guiName == NTB_NULL || *guiName == '\0')
    {
        NTB_ERROR("Null or empty GUI name string!");
        return NTB_NULL;
    }

    if (!g_libraryIsInit)
    {
        NTB_ERROR("NTB not initialized! Call ntb::initialize() first!");
        return NTB_NULL;
    }

    GUI * newGUI = NTB_NEW GUI(guiName);
    getGUIList().pushBack(newGUI);
    return newGUI;
}

bool destroyGUI(GUI * gui)
{
    if (gui == NTB_NULL || !g_libraryIsInit)
    {
        // No NTB_ERROR generated by design.
        return false;
    }

    // First make sure the GUI is actually linked to the global list:
    if (!findGUI(gui->getName().getCString()))
    {
        return false;
    }

    getGUIList().unlinkAndDelete(gui);
    return true;
}

GUI * findGUI(const char * guiName)
{
    if (guiName == NTB_NULL || *guiName == '\0')
    {
        NTB_ERROR("Null or empty GUI name string!");
        return NTB_NULL;
    }

    if (!g_libraryIsInit)
    {
        NTB_ERROR("NTB not initialized! Call ntb::initialize() first!");
        return NTB_NULL;
    }

    GUI * pGUI = getGUIList().getFirst<GUI>();
    for (int count = getGUIList().getSize(); count--; pGUI = pGUI->getNext<GUI>())
    {
        if (pGUI->getName() == guiName)
        {
            return pGUI;
        }
    }
    return NTB_NULL;
}

// ========================================================
// class Variable:
// ========================================================

Variable::Variable(Panel * owner, Variable * parent, const char * name)
    : VarDisplayWidget(owner->getGUI(), owner->getWindowWidget(), parent, name)
{
    //TODO
    (void)parent;
}

Variable::~Variable()
{
    // Anchor the vtable here to avoid
    // '-Wweak-vtables' from Clang.
}

const SmallStr & Variable::getName() const
{
    return VarDisplayWidget::getVarName();
}

const VarDisplayWidget * Variable::getVarDisplayWidget() const
{
    return static_cast<const VarDisplayWidget *>(this);
}

VarDisplayWidget * Variable::getVarDisplayWidget()
{
    return static_cast<VarDisplayWidget *>(this);
}

// ========================================================
// class Panel:
// ========================================================

Panel::Panel(GUI * myGUI, const char * name)
    : WindowWidget(myGUI, NTB_NULL, makeRect(50+pan_xof, 50+pan_yof, NTB_SCALED(333)+pan_xof, NTB_SCALED(300)+pan_yof), name)
    , panelName(name)
{
    //TEMP
    pan_xof += 180;
    pan_yof += 80;
}

Panel::~Panel()
{
    destroyAllVariables();
}

Variable * Panel::findVariable(const char * varName) const
{
    if (varName == NTB_NULL || *varName == '\0')
    {
        NTB_ERROR("Null or empty var name string!");
        return NTB_NULL;
    }

    Variable * pVar = variables.getFirst<Variable>();
    for (int count = variables.getSize(); count--; pVar = pVar->getNext<Variable>())
    {
        if (pVar->getName() == varName)
        {
            return pVar;
        }
    }
    return NTB_NULL;
}

bool Panel::destroyVariable(Variable * var)
{
    if (var == NTB_NULL) // Null pointer proof.
    {
        return false;
    }

    // We don't take chances. Make sure the Variable actually
    // belongs to this Panel before attempting to remove it.
    if (!findVariable(var->getName().getCString()))
    {
        return false;
    }

    variables.unlinkAndDelete(var);
    return true;
}

void Panel::destroyAllVariables()
{
    variables.unlinkAndDeleteAll();
}

Variable * Panel::addVarImpl(Variable * var)
{
    variables.pushBack(var);
    var->onLinkedToPanel(*this);
    onAdjustLayout();
    return var;
}

void Panel::onAdjustLayout()
{
    WindowWidget::onAdjustLayout();
    if (variables.isEmpty())
    {
        return;
    }

    // Initially set to arbitrarily large values.
    int smallestRectWidth = 0xFFFFF;
    int smallestRectXMin  = 0xFFFFF;
    //int smallestRectXMax  = 0xFFFFF;
    const Rectangle usableRect = getUsableRect();

    Variable * pVar = variables.getFirst<Variable>();
    int offsetY = pVar->getRect().yMins;

    // For each user variable in the panel, collapse hidden/minimized var entries:
    for (int count = variables.getSize(); count--; pVar = pVar->getNext<Variable>())
    {
        Rectangle varRect = pVar->getRect();
        //varRect.yMins = panelRect.yMins + TitleBarHeight + offsetY;
        varRect.yMins = offsetY;
        varRect.yMaxs = varRect.yMins + NTB_SCALED(16); // USE A CONSTANT INSTEAD (VarDisplayWidget::Size or something)
        pVar->setRect(varRect);
        pVar->onAdjustLayout();

        // The ones scrolled out of view are not visible, but we need to account for them,
        // otherwise the positions would get messed up when returning into view.
        if (!pVar->isMinimized())
        {
            // Save the smallest var display rect in case we need to adjust them all.
            varRect = pVar->getDataDisplayRect();
            if (varRect.getWidth() < smallestRectWidth)
            {
                smallestRectWidth = varRect.getWidth();
                smallestRectXMin  = varRect.xMins;
                //smallestRectXMax  = varRect.xMaxs;
            }

            offsetY += NTB_SCALED(16+8); //FIXME temp
        }
    }

    // For the scroll bar adjust
    int varsScrolledOutOfView = 0;
    int varsNotMinimized      = 0;

    pVar = variables.getFirst<Variable>();
    offsetY = pVar->getRect().yMins;

    // Now hide the ones scrolled out and show the ones back in:
    for (int count = variables.getSize(); count--; pVar = pVar->getNext<Variable>())
    {
        Rectangle varRect = pVar->getRect();

        // Check if scrolled out of view (up or down):
        if (!usableRect.containsPoint(varRect.xMaxs, varRect.yMaxs) ||
            !usableRect.containsPoint(varRect.xMins, varRect.yMins))
        {
            // Not in the usable panel area anymore.
            pVar->setScrolledOutOfView(true);
            //pVar->setColors(&my_test_colors[1]);
            pVar->setVisible(false);
            //continue;
        }

        // Check if the var field returned into view after being
        // scrolled-in either by scroll-bar or panel resize.
        if (pVar->isScrolledOutOfView())
        {
            if (usableRect.containsPoint(varRect.xMaxs, varRect.yMaxs) &&
                usableRect.containsPoint(varRect.xMins, varRect.yMins))
            {
                // Was off-screen, now back in view.
                pVar->setScrolledOutOfView(false);
                if (!pVar->isMinimized())
                {
                    pVar->setVisible(true);
                    //pVar->setColors(&my_test_colors[0]);
                    //varRect.yMins = panelRect.yMins + TitleBarHeight + offsetY;
                    varRect.yMins = offsetY;
                    varRect.yMaxs = varRect.yMins + NTB_SCALED(16); // USE A CONSTANT INSTEAD (VarDisplayWidget::Size or something)
                    pVar->setRect(varRect);
                    pVar->onAdjustLayout();
                }
            }
        }

        if (!pVar->isMinimized())
        {
            offsetY += NTB_SCALED(16+8); //FIXME temp
            if (pVar->isScrolledOutOfView())
            {
                ++varsScrolledOutOfView;
            }
            ++varsNotMinimized;
        }

        // Align the data fields of the vars to the shortest one.
        //TODO NOTE: this is better if done only when adding new vars!
        Rectangle dataRect = pVar->getDataDisplayRect();
        dataRect.xMins = smallestRectXMin;
        //dataRect.xMaxs = smallestRectXMax;
        pVar->setDataDisplayRect(dataRect);

//      printf("VAR(%p): %s (parent: %p)\n", pVar, pVar->getName().getCStr(), pVar->getParent());
//      printf("visible:   %d\n", pVar->isVisible());
//      printf("minimized: %d\n", pVar->isMinimized());
//      printf("scrolled:  %d\n", pVar->isScrolledOutOfView());
//      printf("---------------\n");
    }

    getScrollBar().updateLineScrollState(varsNotMinimized, varsScrolledOutOfView);
}

void Panel::onScrollContentUp()
{
    if (variables.isEmpty()) { return; }

    Variable * pVar = variables.getFirst<Variable>();
    pVar->onMove(0, pVar->getRect().getHeight() + NTB_SCALED(9));
    onAdjustLayout();
}

void Panel::onScrollContentDown()
{
    if (variables.isEmpty()) { return; }

    Variable * pVar = variables.getFirst<Variable>();
    pVar->onMove(0, -(pVar->getRect().getHeight() + NTB_SCALED(9)));
    onAdjustLayout();
}

bool Panel::onMouseScroll(const int yScroll)
{
    // Variable values that are incrementable/decrementable
    // can be edited by clicking and holding the left mouse
    // button over the value, then scrolling the mouse wheel.
    Variable * pVar = variables.getFirst<Variable>();
    for (int count = variables.getSize(); count--; pVar = pVar->getNext<Variable>())
    {
        if (pVar->onMouseScroll(yScroll))
        {
            return true;
        }
    }
    return WindowWidget::onMouseScroll(yScroll);
}

void Panel::onDraw(GeometryBatch & geoBatch) const
{
    // The user variable might have been changed outside NTB,
    // so we can't assume our cached value is still valid.
    Variable * pVar = variables.getFirst<Variable>();
    for (int count = variables.getSize(); count--; pVar = pVar->getNext<Variable>())
    {
        pVar->onUpdateCachedValue();
    }

    WindowWidget::onDraw(geoBatch);
}

const WindowWidget * Panel::getWindowWidget() const
{
    return static_cast<const WindowWidget *>(this);
}

WindowWidget * Panel::getWindowWidget()
{
    return static_cast<WindowWidget *>(this);
}

const GUI * Panel::getGUI() const
{
    return WindowWidget::getGUI();
}

GUI * Panel::getGUI()
{
    return WindowWidget::getGUI();
}

#if NEO_TWEAK_BAR_DEBUG
void Panel::printHierarchy(std::ostream & out, const SmallStr & indent) const
{
    out << "\n";
    out << "--------------------------------------\n";
    out << "Panel " << getName().getCString() << "\n";
    out << "--------------------------------------\n";
    out << "\n";
    WindowWidget::printHierarchy(out, indent);
    out << "\n";
}
#endif // NEO_TWEAK_BAR_DEBUG

// ========================================================
// class GUI:
// ========================================================

GUI::GUI(const char * name)
    : guiName(name)
{
}

GUI::~GUI()
{
    destroyAllPanels();
}

Panel * GUI::createPanel(const char * panelName)
{
    if (panelName == NTB_NULL || *panelName == '\0')
    {
        NTB_ERROR("Null or empty panel name string!");
        return NTB_NULL;
    }

    Panel * newPanel = NTB_NEW Panel(this, panelName);
    panels.pushBack(newPanel);
    return newPanel;
}

bool GUI::destroyPanel(Panel * panel)
{
    if (panel == NTB_NULL) // Null pointer proof.
    {
        return false;
    }

    // We don't take chances. Make sure the Panel actually
    // belongs to this GUI list before attempting to remove it.
    if (!findPanel(panel->getName().getCString()))
    {
        return false;
    }

    panels.unlinkAndDelete(panel);
    return true;
}

Panel * GUI::findPanel(const char * panelName) const
{
    if (panelName == NTB_NULL || *panelName == '\0')
    {
        NTB_ERROR("Null or empty panel name string!");
        return NTB_NULL;
    }

    Panel * pPanel = panels.getFirst<Panel>();
    for (int count = panels.getSize(); count--; pPanel = pPanel->getNext<Panel>())
    {
        if (pPanel->getName() == panelName)
        {
            return pPanel;
        }
    }
    return NTB_NULL;
}

void GUI::destroyAllPanels()
{
    panels.unlinkAndDeleteAll();
}

void GUI::onFrameRender(const bool forceRefresh)
{
    (void)forceRefresh;
    //Note: maybe here we walk the panel hierarchy
    //and decide if it has changed and needs to be
    //rebuilt. If not, we could keep the previous batch
    //alive and just resubmit it!
    //TODO consider this:
    //
    // if not widgetsModified
    // {
    //     prevGeoBatch.resubmit();
    // }
    // else
    //   ...
    //
    // If forceRefresh is set, then always regen the batch.
    // Passing a true forceRefresh is necessary if the user
    // is changing the var pointers programatically, since
    // otherwise we can't guess they have changed from the library.
    // But avoiding regen the batch every frame is a pretty cool idea!
    //

    int count = panels.getSize();
    if (count <= 0)
    {
        return;
    }

    geoBatch.beginDraw();

    // Start from the end of the list and iterate backwards, since the element
    // with focus is at the head of the sequence, so it draws last at the top.
    Panel * pPanel = panels.getLast<Panel>();
    for (; count--; pPanel = pPanel->getPrev<Panel>())
    {
        pPanel->onDraw(geoBatch);
    }

    geoBatch.endDraw();
}

bool GUI::onMouseButton(const MouseButton::Enum button, const int clicks)
{
    Panel * pPanel = panels.getFirst<Panel>();
    for (int count = panels.getSize(); count--; pPanel = pPanel->getNext<Panel>())
    {
        if (pPanel->onMouseButton(button, clicks))
        {
            // Move panel to the front of the list if not
            // already there, since it now has input focus.
            Panel * pActivePanel = panels.getFirst<Panel>();
            if (pPanel != pActivePanel)
            {
                panels.unlink(pPanel);
                panels.pushFront(pPanel);

                if (pActivePanel != NTB_NULL)
                {
                    // Might have an active edit field that needs resetting.
                    pActivePanel->onDisableEditing();
                }
            }
            return true;
        }
    }

    return false; // Event not handled. Caller may propagate it.
}

bool GUI::onMouseMotion(const int mx, const int my)
{
    Panel * pPanel = panels.getFirst<Panel>();
    for (int count = panels.getSize(); count--; pPanel = pPanel->getNext<Panel>())
    {
        if (pPanel->onMouseMotion(mx, my))
        {
// doesn't seem necessary anymore...
/*
            // Make sure we clear all other elements in case they overlap.
            // If this is not done, overlapping elements might keep on-hover
            // effects enabled even if the cursor has moved to a window on top.
            int n = panels.getSize();
            Panel * pOther = panels.getFirst<Panel>();
            for (; n--; pOther = pOther->getNext<Panel>())
            {
                if (pOther != pPanel) // Don't clear self!
                {
                    pOther->clearFocus();
                }
            }
*/
            return true; // Even handled by this element.
        }
    }

    return false; // Event not handled. Caller may propagate it.
}

bool GUI::onMouseScroll(const int yScroll)
{
    Panel * pPanel = panels.getFirst<Panel>();
    for (int count = panels.getSize(); count--; pPanel = pPanel->getNext<Panel>())
    {
        if (pPanel->onMouseScroll(yScroll))
        {
            return true; // Even handled by this element.
        }
    }

    return false; // Event not handled. Caller may propagate it.
}

const ColorScheme * GUI::getNormalColors() const
{
    //TODO this is a temporary for testing only. User should set this instead.
    static const ColorScheme test_colors_normal = {
        // box
        {
        packColor(100, 100, 100, 255),
        packColor(100, 100, 100, 255),
        packColor(100, 100, 100, 255),
        packColor(100, 100, 100, 255),
        packColor(000, 000, 000, 255), //top
        packColor(000, 000, 000, 255), //bottom
        packColor(80,  80,  80,  255), //left
        packColor(000, 000, 000, 255), //right
        },
        // shadow
        {
        packColor(0, 0, 0, 128),
        packColor(0, 0, 0, 20),
        4,
        },
        // text
        {
        packColor(255, 255, 255, 255),
        packColor(255, 255, 255, 255),
        packColor(255, 255, 255, 255),
        }
    };
    return &test_colors_normal;
}

const ColorScheme * GUI::getHighlightedColors() const
{
    //TODO this is a temporary for testing only. User should set this instead.
    static const ColorScheme test_colors_mousehover = {
        // box
        {
        packColor(110, 110, 110, 255),
        packColor(110, 110, 110, 255),
        packColor(110, 110, 110, 255),
        packColor(110, 110, 110, 255),
        packColor(000, 000, 000, 255), //top
        packColor(000, 000, 000, 255), //bottom
        packColor(80,  80,  80,  255), //left
        packColor(000, 000, 000, 255), //right
        },
        // shadow
        {
        packColor(0, 0, 0, 128),
        packColor(0, 0, 0, 20),
        4,
        },
        // text
        {
        packColor(255, 255, 255, 255),
        packColor(255, 255, 255, 255),
        packColor(255, 255, 255, 255),
        }
    };
    return &test_colors_mousehover;
}

// ================================================================================================
//
//                         Implementation details / internal support code
//
// ================================================================================================

namespace detail
{

// ========================================================
// class EnumValEx:
// ========================================================

// Anchoring the vtable to this file.
EnumValEx::~EnumValEx() { }

// ========================================================
// class VarHierarchyParent:
// ========================================================

VarHierarchyParent::VarHierarchyParent(Panel * owner, Variable * parent, const char * name)
    : Variable(owner, parent, name)
{
}

VarHierarchyParent::~VarHierarchyParent()
{
    // Anchor the vtable here to avoid
    // '-Wweak-vtables' from Clang.
}

void VarHierarchyParent::onDraw(GeometryBatch & geoBatch) const
{
    VarDisplayWidget::onDraw(geoBatch);
    if (!isVisible())
    {
        return;
    }

    // Var name on left side is all that the hierarchy parent draws.
    drawVarName(geoBatch);
}

Variable::Access VarHierarchyParent::getAccessMode() const
{
    return Variable::ReadOnly;
}

Variable * VarHierarchyParent::setNumberFormatting(int)
{
    return this;
}

Variable * VarHierarchyParent::setMaxStringSize(int)
{
    return this;
}

void VarHierarchyParent::onUpdateCachedValue() const
{
}

void VarHierarchyParent::onUpdateUserValue() const
{
}

void VarHierarchyParent::onLinkedToPanel(Panel &)
{
}

} // namespace detail {}
} // namespace ntb {}
